(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var _ExtImgColor = require('./js/ExtImgColor');

var _ExtImgColor2 = _interopRequireDefault(_ExtImgColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var extImgColor = new _ExtImgColor2.default();

if (window) window.extImgColor = extImgColor;

module.exports = extImgColor;

},{"./js/ExtImgColor":4}],2:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PQueue = require('./PQueue');

var _PQueue2 = _interopRequireDefault(_PQueue);

var _tool = require('./tool');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CMap = function () {
  function CMap() {
    _classCallCheck(this, CMap);

    this.vboxes = new _PQueue2.default(function (a, b) {
      return (0, _tool.naturalOrder)(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());
    });
  }

  _createClass(CMap, [{
    key: 'push',
    value: function push(vbox) {
      this.vboxes.push({
        vbox: vbox,
        color: vbox.avg()
      });
    }
  }, {
    key: 'palette',
    value: function palette() {
      return this.vboxes.map(function (vb) {
        return vb.color;
      });
    }
  }, {
    key: 'size',
    value: function size() {
      return this.vboxes.size();
    }
  }, {
    key: 'map',
    value: function map(color) {
      for (var i = 0, max = this.size(); i < max; i++) {
        if (this.vboxes.peek(i).vbox.contains(color)) return this.vboxes.peek(i).color;
      }

      return this.nearest(color);
    }
  }, {
    key: 'nearest',
    value: function nearest(color) {
      var vboxes = this.vboxes;
      var min = Math.pow(255, 3);
      var d2 = Math.pow(255, 3);
      var pColor = null;

      for (var i = 0, max = this.size(); i < max; i++) {
        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));

        if (d2 < min) {
          min = d2;
          pColor = vboxes.peek(i).color;
        }
      }

      return pColor;
    }
  }]);

  return CMap;
}();

module.exports = CMap;

},{"./PQueue":7,"./tool":9}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CanvasImage = function () {
  function CanvasImage(image) {
    _classCallCheck(this, CanvasImage);

    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('2d');

    document.body.appendChild(this.canvas);
    this.width = this.canvas.width = image.naturalWidth;
    this.height = this.canvas.height = image.naturalHeight;

    this.context.drawImage(image, 0, 0, this.width, this.height);
  }

  _createClass(CanvasImage, [{
    key: 'clear',
    value: function clear() {
      this.context.clearRect(0, 0, this.width, this.height);
    }
  }, {
    key: 'update',
    value: function update(imageData) {
      this.context.putImageData(imageData, 0, 0);
    }
  }, {
    key: 'getPixelCount',
    value: function getPixelCount() {
      return this.width * this.height;
    }
  }, {
    key: 'getImageData',
    value: function getImageData() {
      return this.context.getImageData(0, 0, this.width, this.height);
    }
  }, {
    key: 'removeCanvas',
    value: function removeCanvas() {
      this.canvas.parentNode.removeChild(this.canvas);
    }
  }]);

  return CanvasImage;
}();

exports.default = CanvasImage;

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CanvasImage = require('./CanvasImage');

var _CanvasImage2 = _interopRequireDefault(_CanvasImage);

var _MMCQ = require('./MMCQ');

var _MMCQ2 = _interopRequireDefault(_MMCQ);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExtImgColor = function () {
  function ExtImgColor() {
    _classCallCheck(this, ExtImgColor);
  }

  _createClass(ExtImgColor, [{
    key: 'getColorAsync',
    value: function getColorAsync(sourceImage, quality) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var color = _this.getColor(sourceImage, quality);

        if (color) resolve(color);else reject(color);
      });
    }
  }, {
    key: 'getPaletteAsync',
    value: function getPaletteAsync(sourceImage, colorCount, quality) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var palette = _this2.getPalette(sourceImage, colorCount, quality);

        if (palette) resolve(palette);else reject(palette);
      });
    }
  }, {
    key: 'getColor',
    value: function getColor(sourceImage, quality) {
      var palette = this.getPalette(sourceImage, 5, quality);
      return palette[0];
    }
  }, {
    key: 'getPalette',
    value: function getPalette(sourceImage, colorCount, quality) {
      if (typeof colorCount !== 'number' || colorCount < 2 || colorCount > 256) {
        colorCount = 10;
      }
      if (typeof quality !== 'number' || quality < 1) {
        quality = 10;
      }

      // Create custom CanvasImage object
      var image = new _CanvasImage2.default(sourceImage);
      var imageData = image.getImageData();
      var pixels = imageData.data;
      var pixelCount = image.getPixelCount();
      // Store the RGB values in an array format suitable for quantize function
      var pixelArray = [];
      for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {
        offset = i * 4;
        r = pixels[offset + 0];
        g = pixels[offset + 1];
        b = pixels[offset + 2];
        a = pixels[offset + 3];
        // If pixel is mostly opaque and not white
        if (a >= 125) {
          if (!(r > 250 && g > 250 && b > 250)) {
            pixelArray.push([r, g, b]);
          }
        }
      }

      // Send array to quantize function which clusters values
      // using median cut algorithm
      var cmap = _MMCQ2.default.quantize(pixelArray, colorCount);
      var palette = cmap ? cmap.palette() : null;
      // Clean up
      image.removeCanvas();
      return palette;
    }
  }]);

  return ExtImgColor;
}();

exports.default = ExtImgColor;

},{"./CanvasImage":3,"./MMCQ":6}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var sigbits = 5;
var rshift = 8 - sigbits;

// get reduced-space color index for a pixel
function getColorIndex(r, g, b) {
  return (r << 2 * sigbits) + (g << sigbits) + b;
}

// histo (1-d array, giving the number of pixels in
// each quantized region of color space), or null on error
function getHisto(pixels) {
  var histosize = 1 << 3 * sigbits;

  var histo = new Array(histosize),
      index = void 0,
      rval = void 0,
      gval = void 0,
      bval = void 0;

  pixels.forEach(function (pixel) {
    rval = pixel[0] >> rshift;
    gval = pixel[1] >> rshift;
    bval = pixel[2] >> rshift;
    index = getColorIndex(rval, gval, bval);
    histo[index] = (histo[index] || 0) + 1;
  });

  return histo;
}

exports.sigbits = sigbits;
exports.rshift = rshift;
exports.getHisto = getHisto;
exports.getColorIndex = getColorIndex;

},{}],6:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PQueue = require('./PQueue');

var _PQueue2 = _interopRequireDefault(_PQueue);

var _CMap = require('./CMap');

var _CMap2 = _interopRequireDefault(_CMap);

var _VBox = require('./VBox');

var _VBox2 = _interopRequireDefault(_VBox);

var _tool = require('./tool');

var _Histo = require('./Histo');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MMCQ = function () {
  function MMCQ() {
    _classCallCheck(this, MMCQ);
  }

  _createClass(MMCQ, [{
    key: 'medianCutApply',
    value: function medianCutApply(histo, vbox) {
      var rw = vbox.r2 - vbox.r1 + 1,
          gw = vbox.g2 - vbox.g1 + 1,
          bw = vbox.b2 - vbox.b1 + 1,
          maxw = Math.max(rw, gw, bw);

      // only one pixel, no split
      if (vbox.count() == 1) {
        return [vbox.copy()];
      }

      /* Find the partial sum arrays along the selected axis. */
      var total = 0,
          partialsum = [],
          lookaheadsum = [],
          i = void 0,
          j = void 0,
          k = void 0,
          sum = void 0,
          index = void 0;

      if (maxw == rw) {
        for (i = vbox.r1; i <= vbox.r2; i++) {
          sum = 0;
          for (j = vbox.g1; j <= vbox.g2; j++) {
            for (k = vbox.b1; k <= vbox.b2; k++) {
              index = (0, _Histo.getColorIndex)(i, j, k);
              sum += histo[index] || 0;
            }
          }
          total += sum;
          partialsum[i] = total;
        }
      } else if (maxw == gw) {
        for (i = vbox.g1; i <= vbox.g2; i++) {
          sum = 0;
          for (j = vbox.r1; j <= vbox.r2; j++) {
            for (k = vbox.b1; k <= vbox.b2; k++) {
              index = (0, _Histo.getColorIndex)(j, i, k);
              sum += histo[index] || 0;
            }
          }
          total += sum;
          partialsum[i] = total;
        }
      } else {
        /* maxw == bw */
        for (i = vbox.b1; i <= vbox.b2; i++) {
          sum = 0;
          for (j = vbox.r1; j <= vbox.r2; j++) {
            for (k = vbox.g1; k <= vbox.g2; k++) {
              index = (0, _Histo.getColorIndex)(j, k, i);
              sum += histo[index] || 0;
            }
          }
          total += sum;
          partialsum[i] = total;
        }
      }

      partialsum.forEach(function (d, i) {
        lookaheadsum[i] = total - d;
      });

      function doCut(color) {
        var dim1 = color + '1',
            dim2 = color + '2';

        var left = void 0,
            right = void 0,
            vbox1 = void 0,
            vbox2 = void 0,
            d2 = void 0,
            count2 = 0;

        for (i = vbox[dim1]; i <= vbox[dim2]; i++) {
          if (partialsum[i] > total / 2) {
            left = i - vbox[dim1];
            right = vbox[dim2] - i;

            d2 = left <= right ? Math.min(vbox[dim2] - 1, ~~(i + right / 2)) : Math.max(vbox[dim1], ~~(i - 1 - left / 2));

            // avoid 0-count boxes
            while (!partialsum[d2]) {
              d2++;
            }count2 = lookaheadsum[d2];
            while (!count2 && partialsum[d2 - 1]) {
              count2 = lookaheadsum[--d2];
            } // set dimensions
            vbox1 = vbox.copy();
            vbox2 = vbox.copy();

            vbox1[dim2] = d2;
            vbox2[dim1] = vbox1[dim2] + 1;

            //  console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());
            return [vbox1, vbox2];
          }
        }
      }

      // determine the cut planes
      return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');
    }
  }, {
    key: 'quantize',
    value: function quantize(pixels, maxcolors) {
      // short-circuit
      if (!pixels.length || maxcolors < 2 || maxcolors > 256) {
        //  console.log('wrong number of maxcolors');
        return false;
      }

      var histo = (0, _Histo.getHisto)(pixels);

      // get the beginning vbox from the colors
      var vbox = _VBox2.default.vboxFromPixels(pixels, histo);

      var pq = new _PQueue2.default(function (a, b) {
        return (0, _tool.naturalOrder)(a.count(), b.count());
      });
      pq.push(vbox);

      var fractByPopulations = 0.75;
      // first set of colors, sorted by population
      this.iter(histo, pq, fractByPopulations * maxcolors);

      // Re-sort by the product of pixel occupancy times the size in color space.
      var pq2 = new _PQueue2.default(function (a, b) {
        return (0, _tool.naturalOrder)(a.count() * a.volume(), b.count() * b.volume());
      });

      while (pq.size()) {
        pq2.push(pq.pop());
      }
      pq2.push(vbox);

      // next set - generate the median cuts using the (npix * vol) sorting.
      this.iter(histo, pq2, maxcolors - pq2.size());

      // calculate the actual colors
      var cmap = new _CMap2.default();
      while (pq2.size()) {
        cmap.push(pq2.pop());
      }

      return cmap;
    }
  }, {
    key: 'iter',
    value: function iter(histo, pQueue, target) {
      var maxIterations = 1000;

      var ncolors = 1,
          niters = 0;
      /**
       * @type {VBox}
       */
      var vbox = void 0;

      while (niters < maxIterations) {
        vbox = pQueue.pop();

        if (!vbox.count()) {
          pQueue.push(vbox);
          niters++;
          // if(pQueue.size()) continue;
          continue;
        }

        // do the cut
        var vboxes = this.medianCutApply(histo, vbox);
        var vbox1 = vboxes[0],
            vbox2 = vboxes[1];

        if (!vbox1) {
          //  console.log("vbox1 not defined; shouldn't happen!");
          return;
        }

        pQueue.push(vbox1);

        if (vbox2) {
          pQueue.push(vbox2);
          ncolors++;
        }

        if (ncolors >= target) return;

        if (niters++ > maxIterations) {
          //  console.log("infinite loop; perhaps too few pixels!");
          return;
        }
      }
    }
  }]);

  return MMCQ;
}();

module.exports = new MMCQ();

},{"./CMap":2,"./Histo":5,"./PQueue":7,"./VBox":8,"./tool":9}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PQueue = function () {
  function PQueue(comparator) {
    _classCallCheck(this, PQueue);

    this.contents = [];
    this.sorted = false;
    this.comparator = comparator;
  }

  _createClass(PQueue, [{
    key: "sort",
    value: function sort() {
      this.contents.sort(this.comparator);
      this.sorted = true;
    }
  }, {
    key: "push",
    value: function push(o) {
      this.contents.push(o);
      this.sorted = false;
    }
  }, {
    key: "peek",
    value: function peek(index) {
      if (!this.sorted) this.sort();
      if (index === undefined) index = this.contents.length - 1;
      return this.contents[index];
    }
  }, {
    key: "pop",
    value: function pop() {
      if (!this.sorted) this.sort();
      return this.contents.pop();
    }
  }, {
    key: "size",
    value: function size() {
      return this.contents.length;
    }
  }, {
    key: "map",
    value: function map(f) {
      return this.contents.map(f);
    }
  }, {
    key: "debug",
    value: function debug() {
      if (!this.sorted) this.sort();
      return this.contents;
    }
  }]);

  return PQueue;
}();

exports.default = PQueue;


module.exports = PQueue;

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Histo = require('./Histo');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VBox = function () {
  _createClass(VBox, null, [{
    key: 'vboxFromPixels',
    value: function vboxFromPixels(pixels, histo) {
      var rmin = 1000000,
          rmax = 0,
          gmin = 1000000,
          gmax = 0,
          bmin = 1000000,
          bmax = 0,
          rval = void 0,
          gval = void 0,
          bval = void 0;

      // find min/max
      pixels.forEach(function (pixel) {
        rval = pixel[0] >> _Histo.rshift;
        gval = pixel[1] >> _Histo.rshift;
        bval = pixel[2] >> _Histo.rshift;

        rmin = rval < rmin ? rval : rmin;
        gmin = gval < gmin ? gval : gmin;
        bmin = bval < bmin ? bval : bmin;

        rmax = rval > rmax ? rval : rmax;
        gmax = gval > gmax ? gval : gmax;
        bmax = bval > bmax ? bval : bmax;
      });

      return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);
    }
  }]);

  function VBox(r1, r2, g1, g2, b1, b2, histo) {
    _classCallCheck(this, VBox);

    this.r1 = r1;
    this.r2 = r2;
    this.g1 = g1;
    this.g2 = g2;
    this.b1 = b1;
    this.b2 = b2;
    this.histo = histo;
  }

  _createClass(VBox, [{
    key: 'volume',
    value: function volume(force) {
      if (!this._volume || force) {
        this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);
      }
      return this._volume;
    }
  }, {
    key: 'count',
    value: function count(force) {
      var index = 0,
          npix = 0;

      if (!this._count_set || force) {
        for (var i = this.r1; i <= this.r2; i++) {
          for (var j = this.g1; j <= this.g2; j++) {
            for (var k = this.b1; k <= this.b2; k++) {
              index = (0, _Histo.getColorIndex)(i, j, k);
              npix += this.histo[index] || 0;
            }
          }
        }
        this._count = npix;
        this._count_set = true;
      }

      return this._count;
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo);
    }
  }, {
    key: 'avg',
    value: function avg(force) {
      if (!this._avg || force) {
        var mult = 1 << 8 - _Histo.sigbits;

        var ntot = 0,
            hval = 0,
            rsum = 0,
            gsum = 0,
            bsum = 0,
            histoindex = void 0;

        for (var i = this.r1; i <= this.r2; i++) {
          for (var j = this.g1; j <= this.g2; j++) {
            for (var k = this.b1; k <= this.b2; k++) {
              histoindex = (0, _Histo.getColorIndex)(i, j, k);
              hval = this.histo[histoindex] || 0;
              ntot += hval;
              rsum += hval * (i + 0.5) * mult;
              gsum += hval * (j + 0.5) * mult;
              bsum += hval * (k + 0.5) * mult;
            }
          }
        }

        if (ntot) {
          this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];
        } else {
          // console.log('empty box')

          this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];
        }
      }

      return this._avg;
    }
  }, {
    key: 'contains',
    value: function contains(pixel) {
      var rval = pixel[0] >> _Histo.rshift;
      var gval = pixel[1] >> _Histo.rshift;
      var bval = pixel[2] >> _Histo.rshift;

      return rval >= this.r1 && rval <= this.r2 && gval >= this.g1 && gval <= this.g2 && bval >= this.b1 && bval <= this.b2;
    }
  }]);

  return VBox;
}();

exports.default = VBox;

},{"./Histo":5}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function naturalOrder(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

exports.naturalOrder = naturalOrder;

},{}]},{},[1]);
